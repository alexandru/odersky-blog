---
title: "Language and Code"
date: 2024-01-04
---

This is a first trial run for my blog. Let's check whether syntax highlighting works:

```scala
object Test:
  def f(x: String) = s"hello, $x"
```

And something bigger:

```scala
//> using options -YXtypeclass -source future
package hylo

/** A collection of elements accessible by their position. */
trait Collection:
    type Self

    /** The type of the elements in the collection. */
    type Element: Value

    /** The type of a position in the collection. */
    type Position: Value

    extension (self: Self)

        /** Returns `true` iff `self` is empty. */
        def isEmpty: Boolean =
            startPosition `eq` endPosition

        /** Returns the number of elements in `self`.
          *
          * @complexity
          *     O(n) where n is the number of elements in `self`.
          */
        def count: Int =
            val e = endPosition
            def loop(p: Position, n: Int): Int =
                if p `eq` e then n else loop(self.positionAfter(p), n + 1)
            loop(startPosition, 0)

        /** Returns the position of `self`'s first element', or `endPosition` if `self` is empty.
          *
          * @complexity
          *     O(1)
          */
        def startPosition: Position

        /** Returns the "past the end" position in `self`, that is, the position immediately after the
          * last element in `self`.
          *
          * @complexity
          *     O(1).
          */
        def endPosition: Position

        /** Returns the position immediately after `p`.
          *
          * @requires
          *     `p` is a valid position in `self` different from `endPosition`.
          * @complexity
          *     O(1).
          */
        def positionAfter(p: Position): Position

        /** Accesses the element at `p`.
          *
          * @requires
          *     `p` is a valid position in `self` different from `endPosition`.
          * @complexity
          *     O(1).
          */
        def at(p: Position): Element

        /** Returns `true` iff `i` precedes `j`.
          *
          * @requires
          *     `i` and j` are valid positions in `self`.
          * @complexity
          *     O(n) where n is the number of elements in `self`.
          */
        def isBefore(i: Position, j: Position): Boolean =
            val e = self.endPosition
            if i `eq` e then false
            else if j `eq` e then true
            else
                def recur(n: Position): Boolean =
                    if n `eq` j then true
                    else if n `eq` e then false
                    else recur(self.positionAfter(n))
                recur(self.positionAfter(i))

    class Slice2(val base: Self, val bounds: Range[Position]):

        def isEmpty: Boolean =
            bounds.lowerBound.eq(bounds.upperBound)

        def startPosition: Position =
            bounds.lowerBound

        def endPosition: Position =
            bounds.upperBound

        def at(p: Position): Element =
            base.at(p)
    end Slice2

end Collection
```